#!/usr/bin/env bash
set -euo pipefail

# Sync ~/.agents into various coding agents via symlinks.
#
# Source of truth:
#   - ~/.agents/skills                    (Agent Skills standard)
#   - ~/.agents/AGENTS.md                 (shared instructions)
#   - ~/.agents/pi/extensions             (Pi-specific extensions)
#
# Targets:
#   - Codex:  ~/.codex/skills + ~/.codex/AGENTS.md
#   - Claude: ~/.claude/skills + ~/.claude/CLAUDE.md
#   - Pi:     ~/.pi/agent/skills + ~/.pi/agent/AGENTS.md + ~/.pi/agent/extensions

AGENTS_SKILLS_DIR="${HOME}/.agents/skills"
AGENTS_INSTRUCTIONS_FILE="${HOME}/.agents/AGENTS.md"
AGENTS_PI_EXTENSIONS_DIR="${HOME}/.agents/pi/extensions"

CODEX_SKILLS_DIR="${HOME}/.codex/skills"
CLAUDE_SKILLS_DIR="${HOME}/.claude/skills"
PI_SKILLS_DIR="${HOME}/.pi/agent/skills"
PI_EXTENSIONS_DIR="${HOME}/.pi/agent/extensions"

CODEX_INSTRUCTIONS_FILE="${HOME}/.codex/AGENTS.md"
CLAUDE_INSTRUCTIONS_FILE="${HOME}/.claude/CLAUDE.md"
PI_INSTRUCTIONS_FILE="${HOME}/.pi/agent/AGENTS.md"

DRY_RUN=0
YES=0
PRUNE=0

usage() {
  cat <<'EOF'
	Symlink ~/.agents into Codex + Claude + Pi.

Usage:
  sync [--dry-run] [--yes] [--prune]

Options:
  --dry-run   Print planned changes only
  --yes       Apply without prompting
  --prune     Remove skills/extensions from agent folders that are not present in ~/.agents

Notes:
  - ~/.codex/skills/.system is never touched.
  - ~/.agents/AGENTS.md is symlinked to:
      - ~/.codex/AGENTS.md
      - ~/.claude/CLAUDE.md
      - ~/.pi/agent/AGENTS.md
  - Pi extensions are synced from ~/.agents/pi/extensions to ~/.pi/agent/extensions.
EOF
}

while [[ $# -gt 0 ]]; do
  case "$1" in
    --dry-run)
      DRY_RUN=1
      shift
      ;;
    --yes)
      YES=1
      shift
      ;;
    --prune)
      PRUNE=1
      shift
      ;;
    -h | --help)
      usage
      exit 0
      ;;
    *)
      echo "error: unknown argument: $1" >&2
      usage >&2
      exit 2
      ;;
  esac
done

mkdir -p \
  "${AGENTS_SKILLS_DIR}" \
  "${AGENTS_PI_EXTENSIONS_DIR}" \
  "${CODEX_SKILLS_DIR}" \
  "${CLAUDE_SKILLS_DIR}" \
  "${PI_SKILLS_DIR}" \
  "${PI_EXTENSIONS_DIR}"

skills=()
for skill_dir in "${AGENTS_SKILLS_DIR}"/*; do
  [[ -d "${skill_dir}" ]] || continue
  skill_name="$(basename "${skill_dir}")"
  [[ "${skill_name}" == .* ]] && continue
  skills+=("${skill_name}")
done

pi_extensions=()
for entry in "${AGENTS_PI_EXTENSIONS_DIR}"/*; do
  [[ -e "${entry}" ]] || continue
  base="$(basename "${entry}")"
  [[ "${base}" == .* ]] && continue

  if [[ -d "${entry}" ]]; then
    pi_extensions+=("${base}")
    continue
  fi

  if [[ -f "${entry}" ]]; then
    # pi auto-discovers *.ts. Ignore .d.ts (types-only).
    case "${base}" in
      *.d.ts) continue ;;
      *.ts) pi_extensions+=("${base}") ;;
    esac
  fi
done

declare -a plan=()

plan_symlink() {
  local src="$1"
  local dest="$2"
  plan+=("symlink:${src}:${dest}")
}

plan_remove() {
  local path="$1"
  case "${path}" in
    "${CODEX_SKILLS_DIR}"/* | \
    "${CLAUDE_SKILLS_DIR}"/* | \
    "${PI_SKILLS_DIR}"/* | \
    "${PI_EXTENSIONS_DIR}"/* | \
    "${CODEX_INSTRUCTIONS_FILE}" | \
    "${CLAUDE_INSTRUCTIONS_FILE}" | \
    "${PI_INSTRUCTIONS_FILE}")
      plan+=("rmrf:${path}")
      ;;
    *)
      echo "error: refusing to remove unexpected path: ${path}" >&2
      exit 1
      ;;
  esac
}

# --- Skills ---
for skill_name in "${skills[@]}"; do
  skill_dir="${AGENTS_SKILLS_DIR}/${skill_name}"
  for target_root in "${CODEX_SKILLS_DIR}" "${CLAUDE_SKILLS_DIR}" "${PI_SKILLS_DIR}"; do
    target="${target_root}/${skill_name}"

    if [[ -L "${target}" ]]; then
      existing_target="$(readlink "${target}")"
      if [[ "${existing_target}" == "${skill_dir}" ]]; then
        continue
      fi
      plan_remove "${target}"
      plan_symlink "${skill_dir}" "${target}"
      continue
    fi

    if [[ -d "${target}" ]]; then
      plan_remove "${target}"
      plan_symlink "${skill_dir}" "${target}"
      continue
    fi

    if [[ -e "${target}" ]]; then
      echo "skip: ${target} exists and is not a directory/symlink" >&2
      continue
    fi

    plan_symlink "${skill_dir}" "${target}"
  done
done

# --- Instructions ---
if [[ -f "${AGENTS_INSTRUCTIONS_FILE}" ]]; then
  for target in "${CODEX_INSTRUCTIONS_FILE}" "${CLAUDE_INSTRUCTIONS_FILE}" "${PI_INSTRUCTIONS_FILE}"; do
    if [[ -L "${target}" ]]; then
      existing_target="$(readlink "${target}")"
      if [[ "${existing_target}" == "${AGENTS_INSTRUCTIONS_FILE}" ]]; then
        continue
      fi
      plan_remove "${target}"
      plan_symlink "${AGENTS_INSTRUCTIONS_FILE}" "${target}"
      continue
    fi

    if [[ -f "${target}" ]]; then
      plan_remove "${target}"
      plan_symlink "${AGENTS_INSTRUCTIONS_FILE}" "${target}"
      continue
    fi

    if [[ -e "${target}" ]]; then
      echo "skip: ${target} exists and is not a file/symlink" >&2
      continue
    fi

    plan_symlink "${AGENTS_INSTRUCTIONS_FILE}" "${target}"
  done
else
  echo "warn: ${AGENTS_INSTRUCTIONS_FILE} not found; skipping instruction sync" >&2
fi

# --- Pi extensions ---
for ext_name in "${pi_extensions[@]}"; do
  src="${AGENTS_PI_EXTENSIONS_DIR}/${ext_name}"
  dest="${PI_EXTENSIONS_DIR}/${ext_name}"

  if [[ -L "${dest}" ]]; then
    existing_target="$(readlink "${dest}")"
    if [[ "${existing_target}" == "${src}" ]]; then
      continue
    fi
    plan_remove "${dest}"
    plan_symlink "${src}" "${dest}"
    continue
  fi

  if [[ -e "${dest}" ]]; then
    # Match instructions behavior: replace existing file/dir with the symlink.
    plan_remove "${dest}"
    plan_symlink "${src}" "${dest}"
    continue
  fi

  plan_symlink "${src}" "${dest}"
done

# --- Prune ---
if [[ "${PRUNE}" -eq 1 ]]; then
  # Prune skills
  for target_root in "${CODEX_SKILLS_DIR}" "${CLAUDE_SKILLS_DIR}" "${PI_SKILLS_DIR}"; do
    for entry in "${target_root}"/*; do
      [[ -e "${entry}" ]] || continue
      base="$(basename "${entry}")"
      [[ "${base}" == ".system" ]] && continue

      keep=0
      for skill_name in "${skills[@]}"; do
        if [[ "${base}" == "${skill_name}" ]]; then
          keep=1
          break
        fi
      done

      if [[ "${keep}" -eq 0 ]]; then
        plan_remove "${entry}"
      fi
    done
  done

  # Prune pi extensions
  for entry in "${PI_EXTENSIONS_DIR}"/*; do
    [[ -e "${entry}" ]] || continue
    base="$(basename "${entry}")"

    keep=0
    for ext_name in "${pi_extensions[@]}"; do
      if [[ "${base}" == "${ext_name}" ]]; then
        keep=1
        break
      fi
    done

    if [[ "${keep}" -eq 0 ]]; then
      plan_remove "${entry}"
    fi
  done
fi

echo "Planned changes:"
if [[ ${#plan[@]} -eq 0 ]]; then
  echo "  (no changes needed)"
  exit 0
fi

for op in "${plan[@]}"; do
  kind="${op%%:*}"
  rest="${op#*:}"
  case "${kind}" in
    symlink)
      src="${rest%%:*}"
      dest="${rest#*:}"
      echo "  - symlink: ${dest} -> ${src}"
      ;;
    rmrf)
      echo "  - remove: ${rest}"
      ;;
  esac
done

if [[ "${DRY_RUN}" -eq 1 ]]; then
  exit 0
fi

if [[ "${YES}" -ne 1 ]]; then
  if [[ ! -t 0 ]]; then
    echo "error: refusing to apply changes non-interactively without --yes" >&2
    exit 2
  fi

  read -r -p "Apply these changes? [y/N] " answer
  case "${answer}" in
    y | Y | yes | YES) ;;
    *) echo "aborted"; exit 0 ;;
  esac
fi

applied=0
for op in "${plan[@]}"; do
  kind="${op%%:*}"
  rest="${op#*:}"
  case "${kind}" in
    rmrf)
      rm -rf "${rest}"
      ;;
    symlink)
      src="${rest%%:*}"
      dest="${rest#*:}"
      mkdir -p "$(dirname "${dest}")"
      ln -sfn "${src}" "${dest}"
      ;;
  esac
  applied=$((applied + 1))
done

echo "applied ${applied} operations"
